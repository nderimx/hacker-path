# Hacking: the art of exploitation - *notes*

##### *"Thinking of C-source as a program is a common misconception that is expoited by hackers every day."*

## GDB - GNU Debugger
### Prep
#### First use the intel disassembly flavor
`$ echo "set dis intel" > ~/.gdbinit`
<br>The default at&t flavor is just clumsy
#### Debugging flags
* `gcc -g <source.c>` -> use -g in gcc to give gdb access to the source code
* `gdb -q ./a.out` -> use -q in gdb to use the extra information from the -g flag
* `(gdb) list` -> shows you all lines of the source code, so you can break at a specific line
### Commands
#### Examining memory
* `x/4cb 0x8048484` -> examine 4 bytes starting from 0x8048484 in ascii representation
* `x/s 0x8048484` -> examine string starting at 0x8048484 (stops when 0x0 is reached)
* `x/2xw 0x8048484` -> examine 2 words(2 or 4 bytes) in hex
* `x/8db 0x8048484` -> examine 8 bytes in decimal represantation
* `p 0xbffff7bc - 0xbffff7a0` -> get distance between two addresses (result is in decimal)
#### Backtracing the stack
* `bt` -> prints all functions (and local variables) that lead to the current function

## Exploit Protections
#### syscalls like strcpy() are at a slightly different address each time a program containing them is run
since Linux kernel 2.6.11

## General tools
#### CLI calculators
* `$ bc -ql 192*(256^3)+168*(256^2)+256+1`
* `$ pcalc 0y10111011` -> output: `187 0xBB 0y10111011`
* `$ gdb -q --batch -ex "p /d 0x1ab"` -> converts to decimal
#### information revealers
* `$ which <program_name>` finds the binary location
* `$ id $(whoami)` returns the current user's id and its group ids
* `$ hexdump -C <file>` shows bytes alongside their string representations when applicable
* `$ nm <binary>` finds addresses of functions in a program - useful for knowing where to point EIP to get to a desired function location
* `$ diff filename1.c filename2.c`
* `$ objdump -s -j .dtors <binary>` - get specific section
* `$ objdump -h <binary> - list all binary tables and their permissions
* `$ objdump -d -j .plt <binary>` - prints out disassembled section specified
#### tricks
* CTRL+Z pauses a program (puts it in the background), and `$ fg <program_name>` resumes it (puts it back to the foreground)
* piping a string, with multiple "\n" inbetween, to a program which doesn't take arguments, but reads from standard input during execution, allows you to define the interaction with the program berorehand. To illustrate: -y option in many programs, or the yes command does exactly the same, writing constantly: "y\ny\ny\ny\n". Useful with setting up containers and automating buffer overlows that require navigation through stdin.
* `$ cat <file> - | <program>` cat with a dash ( - ) at the end returns standard input to you after doing its job. Useful for writing to a hacked shell.
#### Quick Editing tools and info extractors
* `$ sed -e 's/{old-text}/{new-text}/ filename > filename{2}`
* `$ awk`
* `$ grep`
* `$ head`

## Memory Segmentation
### Segments
#### text (code)
*contains the cpu instructions*<br>
is read only to allow safely running it multiple times concurrently
#### data
*contains initialized global and static variables*<br>
these variables are able to persist across functions because they reside in their own memory segments (data & bss)
#### bss
*contains uninitialized global and static variables*
#### heap
*contains dynamic data buffers created with malloc()*<br>
This is where local and nonlocal array (created with allocators) or struct pointers point to.<br>
-- If (for example) `char var_name[size]` is used, the buffer will be allocated where the variable is located. In other words, not the heap. --<br>
The memory within the heap is managed by allocator and deallocator algorithms, which grow and shrink the heap<br>
Starts at low addresses and grows downward towards higher memory addresses
#### stack
*contains local variables and other stack frame components*<br> Starts at high memory addresses and grows upward towards lower memory addresses<br>
It's used to store context during function calls, and to recover the state before each function call.<br>
*The stack and heap grow towards each other in order to minimize wasted space*<br>
Each time a function is called a new stack frame is created.<br>
##### Stack Frame
* *\<Low addresses>* ...
* ----------end of stack frame----------
* random padding (sometimes)
* local variables
* -if-SFP-used- some DWORDS of padding are added (usually)
* Saved Frame Pointer (SFP) - used to restore EBP *
* Return address (ret) - used to restore EIP
* ----------beginning of stack frame----------
* Function parameters - for the above frame
* *... \<High addresses>*
<br>
 * Sometimes when the funciton is simple enough, the compiler ommits SFP for performance. -fomit-frame-pointer tells the compiler to lower the threshold for ommiting SFP, which makes debugging more difficult. When there is no SFP, the compiler simply keeps exact track of the stack so that it knows when ret is reached (alloca, which moves ESP by a variable amount, may throw the compiler off).

##### Stack Pointers
* ESP -> top of stack (Stack Pointer)
* EBP -> base of top stack frame (Base Pointer)
##### Call instruction
0. before a call instruction, its parameters get moved to the stack (which make up the end of that frame)


1. pushes the return address to the stack (EIP+sizeof(instruction))
2. jumps to the beginning of the called function
#### CPU execution
When a program is executed the EIP is set to point to the first instruction of the code segment.
This is the Processor execution loop:
1. Read instruction EIP points to
2. Add byte length of read instruction to EIP
3. Execute read instruction; ^goto step 1.

## Programming
##### Remember, the processor doesn't know what types are. The machine code tells the processor how many bytes it will read/write on each step.
* `unsigned int hacky_nonpointer = (unsigned int) char_array;` -> this demonstrates that a uint can hold a pointer, however the programmer needs to remember to typecast it correctly. For instance if you want the second element of this array, you would need to remember yourself the type of the elements in order to do this: `hacky_nonpointer += sizeof(char);`. To get the value of a char: `char mychar = *((char *) hacky_nonpointer);`, where `(char *)` casts the variable to a char **pointer**, and `*(...)` dereferences it in order to get the value.
* `malloc()` allocates the given number rounded up so x%8==0 -> returns a void pointer (~uint) - null pointer is returned on error (0x0)
* `free()` deallocates the memory range starting the given pointer
* `void *err_malloc(unsigned int size) {...}` - in this case malloc goes through the error checking function, which *returns a void pointer*, which you don't see often
* simple error handling: `fprintf(stderr, "Error: could not..."); exit(-1);`
* proper error handling: `perror(error_message); exit(-1);` writes error_message to stderr and prints each error message in stderr in reverse order (colon seperated). So you can stack up errors and each time decide what to do (keep stacking, logging them, or exiting and printing them).
* #include \<mylibrary> -> compiler looks for this file in standard include paths (example: /usr/include/mylibrary) | #include "mylibrary" -> compiler looks in the current directory
* memory of a struct is simply all its elements concatenated (without any padding probbably). the element's datatypes are stored in the struct itself (code segment).
* `srand(time(0));` sets a seed which is used by rand(), although rand() doesn't take arguments.
* `bzero(pointer, SIZE);` zeros out the given memory - useful when doing binary manipulations
* `system(command);` creates a new process and executes the given command


## OS stuff
* file descriptors are unique numbers across open files, stored in a table in memory (but there is another table that stores the exact memory locations of every file and is stored in persistant memory), and are passed to other functions (like pointers to the beginning of the file memory)
* a program file with the setuid flag set, always executes with the owners privileges (could be root) (during the execution the current **effective user** is considered to be the owner) even if the user executing it (**real user**) is not the owner (given this user has execution permission). a setuid file should be always write protected and in some cases even read protected.
* the `chsh` program is a setuid program owned by root, which manages the /etc/passwd file. Depending on the real user executing it, chsh allows management of sections of this file.
* "a running program has both a real user ID and an effective user ID." - in C obtainable with `getuid()` and `geteuid()`
* `chmod u+s`

## Exploitation
##### Exploiting a program is simply a clever way of getting the computer to do what you want it to do, even if the currently running program was designed to prevent that action.
###### Most program exploits have to do with memory corruption
##### Security holes are flaws or oversights in the design of the program or the environment.
### When to look for Security holes
* when a program is quickly modified to expand its functionality
* when a service allows limited code execution/interpretation (sanbox environments, browsers,..)
* ...
### Types of Vulnerabilities
* off-by-one error (fencepost error) - for instance counting spaces instead of objects surrounding them
* injections (very often using unicode escape codes)
* buffer overflows
* format string vulnerabilities
* memory leaks
* ...
#### Shellcode
Instructions injected into memory, which get executed by making EIP point to them. Shellcode tells the program to restore privileges and open a shell prompt. If used in a suid program you get a root shell!
### Buffer Overflows
##### If the code doesn't check if an input fits inside an allocated buffer, or if the check has a flaw, a buffer overflow is possible
1. Find distance between unchecked buffer and target variable you want to override
2. Overflow the buffer with that distance plus the payload for the target variable
#### Stack Overflow
* Overriding a critical variable that gets pushed before the buffer
* Overriding ret to change execution flow to the desired location (get access granted!)
* Overriding ret to point to shellcode inside the stack
* Overriding ret to point to shellcode located in the program environment
##### Overriding ret 
Get approximate distance between input buffer and ret, and repeat your own return pointer into the buffer more than that distance, assuming the start of the buffer is aligned with DWORDs on the stack, the ret address should get replaced with the return address that you provided.
##### Shellcode inside the stack
Since the stack looks different depending on the compiler and compiler flags, a NOP sled is needed.<br>
A NOP Sled is the No Operation instruction repeated many times. In x86 the machine instruction is x90. So no matter where you point in the NOP sled, EIP will eventually reach the end of it.
* NOP Sled
* Shellcode
* repeated address (enough times to overflow into ret) that points to middle of NOP Sled
<br>
The tricky part is getting an approximate location of the NOP Sled<br>
One method is experimentally, by using a local varialbe as a reference and subrtacting an offset from it (experiment w/ offset)

###### Experimentally finding the NOP sled
`$ seq 0 1 5` gives you a sequence of 0 to 5 with an increment of 1
`$ for i in $(seq 0 30 300)` loop through with an increment of half the size of the NOP sled, so you don't miss it
`> do`
`> ./exploit $i` execute your exploit with a different offset each time, until it works
`> done`
###### Finishing Exploit
Finally we write a program which assembles the NOP sled, shellcode, and the repeated return address, and feeds them to the function `system()` together with the target program file path.
##### Shellcode inside the Environment
###### With a NOP sled
When there is not enought space in the target stack frame, it's a good idea to put the shellcode in an environment variable. <br>
`$ env` will show you all the current environment variables, which are accessible to any program run in the current shell<br>
`$ export SHELLCODE=$(perl -e 'print "\x90"x200')$(cat shellcode.bin)` sets the env variable, assuming the shellcode is in shellcode.bin<br>
Environment Variables are located near the bottom of the stack. To find our SHELLCODE environment variable run gdb with any program, break at main, examine memory addresses following esp+X (X = couple of hundreds). Look through them till you see `"SHELLCODE=", '\220' \<repeats ...`. Don't know why its '\220' instead of '\144'<br>
Find the address of the middle of the NOP sled (to have wiggle room) while looking through the gdb output.<br>
`$ ./target_program $(perl -e 'print "\x47\xf9\xff\xbf"x40')` where 0xbffff947 is the middle of the NOP sled. This will run the program we want to hack with the repeated pointer as the argument.
###### Without a NOP sled
C's standard library has a function called getenv(env_var), which returns the memory address of an environment variable.<br>
The only problem is that the exact memory location depends on the length of the program's name. So running the program with the "exact address" still crashes it, since the target program might have a different name length than the program which got the memory address using getenv(). You could include in this env_var extracting program the functionality to compensate for this, but there's a cleaner way to use environment variables.
##### Providing a custom Environment
When we look at libc in the `system()` function, which we used to run our target program in the first exploit, we see that it first uses `fork()` to create a new process, and then `execl("/bin/sh", "sh", "-c", cmd, NULL);`, which replaces the current process with the new specified one (I'm not sure how execl() is replacing the new forked process, if at all, especially since it's supposed to replace the "current function"). Since version two of /bin/sh, the setuid privileges get dropped when using system().<br>
We could use directly `execl()`, which uses the current environment, but there is a function: `execle()` which does the exact same thing, with the exception that it uses a provided environment.<br>
An environment with 3 variables looks like this: `char *env[4] = {PATH, HOME, USER, 0};`.<br>
The very bottom of the environment (which is in the stack) is always **0xbffffffa**. The first string there is the program name, in our case "./target_program", which should start at `0xbffffffa`-`strlen("./target_program")`, because the stack grows upward toward lower memory addresses. The second string is the first environment variable.<br>
The same way we got the program name address we, can get the exact memory location of the shellcode, subtracting from `0xbffffffa` the size of the program name, 1 for the null byte which server as a delimiter, and the size of the shellcode: `ret = 0xbffffffa - sizeof(shellcode) - 1 - strlen("./target_program");`<br>
To write the exploit program:
1. create an environment with the only variable being the shellcode: `char *env[2] = {shellcode, 0};`
2. calculate the exact shellcode address and make a large enough *buffer* out of it to overflow ret.
3. then feed these to execle() -> `execle("./target_program", "target_program", buffer, 0, env);`
#### Heap Overflows
* Here the target variable needs to be declared after the input buffer (opposite of stack overflows)
* You can also use heap header information to do stuff... (Need more reading) 
##### Protections
After overflowing a heap buffer, when using free() to unallocate memory, errors in the heap header information are detected, debugging information printed and the program is terminated. Simmilar to segmentation fault in stacks. glibc does this since version 2.2.5 to make heap unlinking in Linux very difficult. (Need more reading on heap unlinking)
#### Function Pointer Overlows (segment doesn't matter)
When a function pointer, which has been set, is called, like any other function, the EIP gets redirected to wherever the funciton address is, or the function pointer points to. So overlowing into a function pointer lets you control EIP!<br>
However, you still need to navigate through the running program (create a scenario) until you get to a point where the function pointer is called after being overwritten.
### Format String Vulnerabilities
They may be outdated...<br>
`printf(fmt_string, argument1, argument2...)` - this looks at each character from fmt_string, and if it's a special character (%), it will look for a format character (d, x, c, s, p, n (together with '%' in front it's called a format identifier), then it will print whatever is at the next argument (argument1..) formatted according to the format character, otherwise it prints the character from the fmt_string if it wasn't a %.<br>
The vulnerability: if there are more special format codes (%s, %x...) than arguments, the printf function will look at the memory location after the last printf parameter/argument, which are located at the end of the previous stack frame.<br>
Frequent programmer mistake: `printf(only_string_to_print);`. Here if the user can control the only_string_to_print, and insert special % characters, they can make it so that printf goes through memory addresses that weren't intended to be looked at. If the user inserts 40 `%x` into the only_string_to_print, then they can read 40 words into the stack after the pointer to only_string_to_print (it's a pointer because it's a stack frame parameter).<br>
Convenient case: if only_string_to_print is created in the stack, and for convenience is the first declared in the function (top of stack), then eventually you will read bytes from that very string. Example: only_string_to_print="AAAA%x%x%x%x%x%x". When using this input, printf will reveal six words total, some of which may be stack frame padding, but getting past the padding you start getting local variables, in our case bytes from the input string: 0x41414141 followed by ascii bytes for '%' and 'x'.
#### Reading from Arbitrary Memory
Using `%s` to print a string, actually prints a string where the argument pointer points to, so instead of writing 'AAAA' at the beginning of the input string, you could insert a memory address and use '%s' so that it aligns with it, and printf will print the string located at the memory address you provided.
#### Writing to Arbitrary Memory
'%n' is a special symbol which instead of reading from memory, it writes to the argument variable. Example: `printf("The number of bytes printed up until this point X%n, are stored in the variable count", count);`. Here count would be 48.<br>
In our previous convenient case if we replaced the '%s' corresponding to the memory address we wanted to read from, with "%n", then printf would write to our provided memory address the number of bytes printed up until "%n". This is how you write to memory, however, it's not very useful spamming the format string with characters to get to a high number, and even impossible to write the value of an address. By using field width modifiers, such as '%100x', the count of the format string gets increased by 100. Using this helps, but it's still not enough to write memory values.
##### Writing "descending memory"
You could also write one byte at a time inside a word. Let's say we want to write to memory address '0x08049794'. We first write the least significant byte to '0x08049794', then the next to '0x08049795', then '0x08049796', and finally to the most significant byte '0x08049797' (remember it's little endian ordering in x86), where in between the memory addresses in the format string, we insert any four bytes (value doesn't matter), and between the '%n' format identifiers, there are '%100x', where instead of 100 you write the difference between each byte we want to write in memory. An example: `"\x94\x97\x04\x08JUNK\x95\x97\x04\x08JUNK\x96\x97\x04\x08JUNK\x97\x97\x04\x08%x%x%126x%n%17x%n%17x%n%17x%n"` -> would write to 0x08049794: 0xddccbbaa<br>
Note: this also writes 3 bytes to the next word.
##### Writing anything
If we wanted to write 0xaabbccdd we would run into a problem after writing dd, the difference between cc and dd is negative, and you can't reduce the count of characters in the format string. However, you could find the difference between 1cc and dd, and put that in the '%{difference}x' format identifier, to write `cc 01 00 00` (in little endian) instead of trying to write `cc 00 00 00`. This way it doesn't matter if the next byte is lower of higher... Except if the next byte is only 3 or lower bytes greater, then that low number you put in the format identifier gets ignored, since there are 4 bytes in "JUNK", and the difference will be exactly four. To circumvent this problem just do the same thing as with lower values.
##### Writing to memory easier
1. `printf("7th: %7$d, 4th: %4$05d \n", 10, 20, 30, 40, 50, 60, 70, 80);` will print `"7th: 70, 4th: 00040"`. So after finding out in which position your format string is, you can simply use **Direct Memory Access**, to directly get to that address. Example of fmt vulnerability string: "AAAA%4$x" would output "AAAA41414141".
2. It's hard to write entire 4 byte memory addresses with field modifiers, but it's easy writing shorts/half-words/two-bytes. printf also uses %hn to write a short instead of a word (such as with %n). This halves the amount of the format string, from making you write 4 bytes individually, you can write 2 shorts individually to make a whole word. On negative differences between the shorts or differences less than 4, you can use the same tricks as with writing individual bytes.
#### Writing to .dtors
Programs compiled with gcc have two tables called .dtors (for destructors) and .ctors (for constructors).<br>
* Constructor functions are executed before main()
* Destructor functions are executed before the main functions exits with the exit syscall
`static void cleanup(void) __attribute__ ((destructor));` - this is how you declare a destructor function header. Afterwards you simply define this declared function like any other.<br>
With nm <binary> you can see that there is a __DTORS_END__ (containing 0x00000000) and __DTORS_LIST__ (containing 0xffffffff). All the Destructor functions should be in-between these two. Turns out .dtors is not read only, so writing a custom or handpicked function pointer to __DTORS_LIST__+4, which would be __DTORS_END__ if there aren't any destructors, would make the program execute your function right before exit is called. So you could get a shell with effective user privileges.
#### Writing to the Global Offset Table
*procedure linkage table (PLT)* is another special section in compiled programs, which contains all external library function pointers (ABI I believe). If you disassemble the plt section, you find library functions (like system calls), which are each defined with a push and jump instruction. You can't simply overwrite a pointer to change execution flow because plt readonly. However, the addresses that plt functions point to, are located in the Global Offset Table, which is writable. GOT does pretty much the same, but is more like a table, and it contains the actual addresses of the external functions. So to change execution flow simply change the address of the desired GOT entry and voila. To get these Records use `objdump -R <binary>` for the DYNAMIC RELOCATION RECORDS (GOT).
### Interesting hacking examples from the book
#### Using a setuid notetaker program to add users with root privileges (heap overflow)
Lets say we have a program that lets you take notes, which only you can read, although with another program, called notesearch.<br>
The way it works is, it gets the real ID of the user, writes it in a file only root can read/write, then writes under that the user provided note. The program notesearch also gets the real user ID, and prints only the lines located below the matching user ID.<br>
There is a buffer in notetaker, which stores the user provided note, and directly after it is the string variable that stores the file path of the notes (this doesn't change throughout the program). Both are pointers which with memory allocated in the heap. Since there is no size check, the buffer can be overlown in the note file path variable. Now you can write stuff with root privileges to a file, like `/etc/passwd`.<br>
/etc/passwd looks something like this:<br>
`root:x:0:0:root:/root:/bin/bash`<br>
`daemon:x:1:1:daemon:/usr/sbin:/bin/sh`<br>
`bin:x:2:2:bin:/bin:/bin/sh`<br>
`sys:x:3:3:sys:/dev:/bin/sh`<br>
`...`<br>
(login_name, password, user_ID, group_ID, username, home_dir, login_shell)<br>
The hashed(and salted) passwords are stored in a shadow file, however the passwd file **can** contain a hashed password instead of an x.<br>
**Any entry in the passwd file with a user ID of 0 will have root privileges.**<br>
`perl -e 'print crypt("password", "AA")` will print the salted hash of "password" with "AA". in python it looks exactly the same, but you need to import crypt and have to use paranthases for print, which doesn't look clear in the command line.<br>
Since the overlowing buffer must end with "etc/passwd" if we want to write to it, the book suggests making the directory "/tmp/etc" then link: `ln -s /bin/bash /tmp/etc/passwd`. This allows the entry for a user to make sense, since the last part of the entry is the login shell, /tmp**/etc/passwd** points to the bash shell /bin/bash. So they are equivalent. I tried a simpler potential solution, which is to put a null byte right before "/etc/passwd", so that you have effectively two separate strings. That doesn't work, because bash strings are implemented using the C definition of a string (NUL terminated), so when you try to sneak in a null byte, it would be identical to passing the program two arguments, however that doesn't happen, instead bash simply ignores the null byte alltogether in this scenario. In order to overflow the filepath variable AND for the entry to still make sense, the username (which is different from the login name) can be filled with as many characters as needed.
## Open questions and challenges
* why is the allocator reusing deallocated heapspace of 100 but not 50, when allocating 15(=>16)?
* In C, for the sake of performance, the programmer is responsible for data integrity, instead of the compiler, since it would do integrity checks on every variable (or maybe only on buffers, idk). Why is Rust almost on par with C when it comes to performance (according to the Rust team, I haven't tested it myself yet)?

<br><br>
*01.01.1970*
